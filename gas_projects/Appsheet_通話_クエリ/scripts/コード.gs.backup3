/**
 * 実行ログモジュール
 */
const ExecutionLogger = {
  SPREADSHEET_ID: '15Z_GT4-pDAnjDpd8vkX3B9FgYlQIQwdUF1QIEj7bVnE',
  SHEET_NAME: 'シート1',
  
  /**
   * ログを記録
   * @param {string} scriptName - スクリプト名
   * @param {string} status - ステータス (SUCCESS/ERROR/WARNING)
   * @param {string} processId - 処理ID
   * @param {string} message - メッセージ
   * @param {string} errorDetail - エラー詳細
   * @param {number} executionTime - 実行時間(秒)
   * @param {Object} inputData - 入力データ
   */
  log: function(scriptName, status, processId, message, errorDetail, executionTime, inputData) {
    try {
      const ss = SpreadsheetApp.openById(this.SPREADSHEET_ID);
      const sheet = ss.getSheetByName(this.SHEET_NAME);
      
      const timestamp = new Date();
      const user = Session.getActiveUser().getEmail();
      const inputDataStr = inputData ? JSON.stringify(inputData).substring(0, 1000) : '';
      
      sheet.appendRow([
        timestamp,
        scriptName,
        status,
        processId || '',
        message || '',
        errorDetail || '',
        executionTime || 0,
        user,
        inputDataStr
      ]);
    } catch (e) {
      Logger.log(`ログ記録エラー: ${e.message}`);
    }
  },
  
  /**
   * 成功ログ
   */
  success: function(scriptName, processId, message, executionTime, inputData) {
    this.log(scriptName, 'SUCCESS', processId, message, '', executionTime, inputData);
  },
  
  /**
   * エラーログ
   */
  error: function(scriptName, processId, message, error, executionTime, inputData) {
    const errorDetail = error ? `${error.message}\n${error.stack}` : '';
    this.log(scriptName, 'ERROR', processId, message, errorDetail, executionTime, inputData);
  },
  
  /**
   * 警告ログ
   */
  warning: function(scriptName, processId, message, executionTime, inputData) {
    this.log(scriptName, 'WARNING', processId, message, '', executionTime, inputData);
  }
};


/**
 * Webhook重複実行防止モジュール
 */
const DuplicationPrevention = {
  LOCK_TIMEOUT: 300000, // 5分
  CACHE_EXPIRATION: 3600, // 1時間
  
  /**
   * リクエストの重複チェック
   * @param {string} requestId - リクエストID（webhookデータのハッシュ値）
   * @return {boolean} - 処理を続行する場合はtrue
   */
  checkDuplicate: function(requestId) {
    const cache = CacheService.getScriptCache();
    const cacheKey = `processed_${requestId}`;
    
    // キャッシュチェック
    if (cache.get(cacheKey)) {
      Logger.log(`重複リクエストを検出: ${requestId}`);
      return false;
    }
    
    // ロック取得
    const lock = LockService.getScriptLock();
    try {
      lock.waitLock(this.LOCK_TIMEOUT);
      
      // 再度キャッシュチェック（ダブルチェック）
      if (cache.get(cacheKey)) {
        Logger.log(`ロック取得後、重複リクエストを検出: ${requestId}`);
        return false;
      }
      
      // 処理済みマークを設定
      cache.put(cacheKey, 'processed', this.CACHE_EXPIRATION);
      return true;
    } catch (e) {
      Logger.log(`ロック取得エラー: ${e.message}`);
      return false;
    } finally {
      lock.releaseLock();
    }
  },
  
  /**
   * リクエストIDを生成
   * @param {Object} data - Webhookデータ
   * @return {string} - リクエストID
   */
  generateRequestId: function(data) {
    const str = JSON.stringify(data);
    return Utilities.computeDigest(
      Utilities.DigestAlgorithm.SHA_256,
      str,
      Utilities.Charset.UTF_8
    ).map(b => (b & 0xFF).toString(16).padStart(2, '0')).join('');
  }
};


/**

 * @fileoverview AppSheetからのWebhookを受け取り、Gemini APIで回答を生成し、AppSheetに書き戻すスクリプト。

 * 詳細なデバッグログ機能、設定のコード内定義、動的なモデル選択機能を搭載。

 */



// --- 1. 基本設定 ---

const SETTINGS = {

  // --- APIキー関連 ---

  GEMINI_API_KEY: 'AIzaSyDUKFlE6_NYGehDYOxiRQcHpjG2l7GZmTY', // Gemini APIキー

  APP_ID: '4762f34f-3dbc-4fca-9f84-5b6e809c3f5f',       // AppSheetのアプリID

  ACCESS_KEY: 'V2-I1zMZ-90iua-47BBk-RBjO1-N0mUo-kY25j-VsI4H-eRvwT', // AppSheet APIのアクセスキー



  // --- AppSheetテーブル名 ---

  QUERIES_TABLE_NAME: 'Call_Queries', // 質疑応答テーブル



  // --- デバッグ & ログ機能 ---

  DEBUG_MODE: true, // trueにするとデバッグメールが送信されます。不要な場合は false にしてください。

  LOG_EMAIL: 't.asai@fractal-group.co.jp', // デバッグログを送信するメールアドレス



  // --- メール件名用設定 ---

  SCRIPT_NAME: '通話関連クエリ', // メール件名に表示するスクリリプトの名前

  ID_LABEL: 'query_id',         // メール件名に表示するIDの名称 (例: QueryID, RecordID など)



  // --- Geminiモデル設定 ---

  // Webhookで指定するキーワードと、実際に使用するGeminiのモデル名を定義します。

  MODEL_MAPPING: {

    "しっかり": "gemini-2.5-pro", // 2.5-proはまだ一般公開されていないため1.5-proにしています

    "はやい": "gemini-2.5-flash" // 2.5-flashはまだ一般公開されていないため1.5-flashにしています

  },

  // Webhookでモデルのキーワード指定がなかった場合に使用する、上記のMODEL_MAPPINGで定義したキーワードです。

  DEFAULT_MODEL_KEYWORD: "しっかり"

};





/**

 * ログを収集し、コンソールに出力する。

 * @param {Array<string>} logCollector - ログを格納する配列。

 * @param {string} message - ログメッセージ。

 */

function log(logCollector, message) {

  const timestamp = new Date().toLocaleString('ja-JP');

  const logMessage = `[${timestamp}] ${message}`;

  console.log(logMessage);

  logCollector.push(logMessage);

}



/**

 * ログ出力用に、オブジェクト内にある指定されたキーの長文テキストを切り詰める。

 * 元のオブジェクトは変更しない。

 * @param {object} obj - 対象のオブジェクト。

 * @param {Array<string>} keysToTruncate - 値を切り詰めるキーのリスト。

 * @param {number} maxLength - 最大文字数。

 * @returns {object} - 値が切り詰められた新しいオブジェクト。

 */

function truncateObjectValuesForLogging(obj, keysToTruncate, maxLength) {

  // 元のオブジェクトを変更しないように、シャローコピーを作成

  const newObj = { ...obj }; 

  

  for (const key of keysToTruncate) {

    if (typeof newObj[key] === 'string' && newObj[key].length > maxLength) {

      newObj[key] = newObj[key].substring(0, maxLength) + '... (省略)';

    }

  }

  return newObj;

}



/**

 * 収集したログを指定されたメールアドレスに送信する。

 * @param {Array<string>} logCollector - ログが格納された配列。

 * @param {string} subject - メールの件名。

 */

function sendDebugLog(logCollector, subject) {

  if (!SETTINGS.DEBUG_MODE || !SETTINGS.LOG_EMAIL) return;

  

  try {

    const body = logCollector.join('\n');

    // Email removed - using execution log instead

  } catch (e) {

    console.error(`ログメールの送信に失敗しました: ${e.toString()}`);

  }

}



/**

 * AppSheetのWebhookからPOSTリクエストを受け取るメイン関数

 * @param {object} e - Webhookイベントオブジェクト

 */

/**
 * AppSheet Webhook エントリーポイント
 * @param {GoogleAppsScript.Events.DoPost} e
 */
function doPost(e) {
  const params = JSON.parse(e.postData.contents);
  return processRequest(params);
}


/**
 * メイン処理関数（引数ベース）
 * @param {Object} params - リクエストパラメータ
 * @returns {Object} - 処理結果
 */
function processRequest(params) {
  const logCollector = [];

  const startTime = new Date();

  let queryId = 'N/A';

  let status = '成功';



  try {

    log(logCollector, '--- 処理開始 ---');

    

    if (!e || !e.postData || !e.postData.contents) {

      throw new Error('POSTデータが存在しません。');

    }

    



    const keysToTruncate = ['promptText', 'callSummary', 'callTranscript', 'call_info'];

    const paramsForLog = truncateObjectValuesForLogging(params, keysToTruncate, 200);

    log(logCollector, `受信したWebhookペイロード: ${JSON.stringify(paramsForLog, null, 2)}`);



    queryId = params.queryId;

    const { promptText, callSummary, callTranscript, call_info, modelKeyword } = params;



    if (!queryId || !promptText) {

      throw new Error('必須パラメータ (queryId, promptText) が不足しています。');

    }

    log(logCollector, `処理対象: ${SETTINGS.ID_LABEL} = ${queryId}`);



    const selectedKeyword = modelKeyword && SETTINGS.MODEL_MAPPING[modelKeyword] ? modelKeyword : SETTINGS.DEFAULT_MODEL_KEYWORD;

    const model = SETTINGS.MODEL_MAPPING[selectedKeyword];

    if (!model) {

        throw new Error(`モデルキーワード '${selectedKeyword}' に対応するモデルがSETTINGS.MODEL_MAPPING内に見つかりません。`);

    }

    log(logCollector, `使用モデル: ${model} (キーワード: ${selectedKeyword})`);



    const answerText = generateAnswerWithGemini(logCollector, promptText, callSummary, callTranscript, call_info, model);

    if (!answerText) {

      throw new Error('AIからの応答が空でした。');

    }

    log(logCollector, `AIからの生成回答（先頭100文字）: ${answerText.substring(0, 100)}...`);



    updateQueryResponse(logCollector, queryId, answerText);

    

  } catch (error) {

    status = 'エラー';

    log(logCollector, `[重大なエラー] 処理が中断されました: ${error.toString()}\nスタックトレース: ${error.stack || 'N/A'}`);

    if (queryId !== 'N/A') {

      try {

        updateQueryStatusToError(logCollector, queryId, error.toString());

      } catch (updateError) {

        log(logCollector, `[追加エラー] AppSheetへのエラーステータス更新に失敗しました: ${updateError.toString()}`);

      }

    }

  } finally {

    const endTime = new Date();

    const elapsedTime = (endTime.getTime() - startTime.getTime()) / 1000;

    log(logCollector, `--- 処理終了 (ステータス: ${status}, 処理時間: ${elapsedTime}秒) ---`);

    

    const subject = `[GASログ] ${SETTINGS.SCRIPT_NAME} (${status}) - ${SETTINGS.ID_LABEL}: ${queryId}`;

    

    sendDebugLog(logCollector, subject);

  }
}


/**
 * テスト用関数
 * GASエディタから直接実行してテスト可能
 */
function testProcessRequest() {
  // TODO: テストデータを設定してください
  const testParams = {
    // 例: callId: "test-123",
    // 例: recordId: "rec-456",
    // 例: action: "CREATE"
  };

  console.log('=== テスト実行: Appsheet_通話_クエリ ===');
  console.log('入力パラメータ:', JSON.stringify(testParams, null, 2));

  try {
    const result = processRequest(testParams);
    console.log('処理成功:', JSON.stringify(result, null, 2));
    return result;
  } catch (error) {
    console.error('処理エラー:', error.message);
    console.error('スタックトレース:', error.stack);
    throw error;
  }
}




/**

 * Gemini APIを呼び出し、回答を生成する

 */

function generateAnswerWithGemini(logCollector, promptText, callSummary, callTranscript, call_info, model) {

  log(logCollector, 'Gemini API 処理開始...');

  

  const prompt = `

# 指示

以下の#参照情報に基づいて、#ユーザーからの質問に的確に回答してください。

**重要: 回答には「はい、わかりました」などの前置きや挨拶を含めず、質問に対する答えそのものだけを生成してください。**



# 参照情報

## 通話の要約

${callSummary || '要約はありません。'}



## 通話の全文文字起こし

${callTranscript || '全文文字起こしはありません。'}



## 通話関連情報

${call_info || '関連する通話はありません。'}



---

# ユーザーからの質問

${promptText}

`;

  

  const requestBody = {

    contents: [{ parts: [{ text: prompt }] }],

    generationConfig: {

      "temperature": 0.3,

      "maxOutputTokens": 20000,

    },

  };



  const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${SETTINGS.GEMINI_API_KEY}`;

  const options = {

    method: 'post',

    contentType: 'application/json',

    payload: JSON.stringify(requestBody),

    muteHttpExceptions: true

  };

  

  log(logCollector, `Gemini APIリクエストURL: ${url}`);

  const requestBodyForLog = {

    ...requestBody,

    contents: [{ parts: [{ text: `(プロンプトの長さ: ${prompt.length}文字)` }] }]

  };

  log(logCollector, `Gemini APIリクエストボディ: ${JSON.stringify(requestBodyForLog, null, 2)}`);



  const response = UrlFetchApp.fetch(url, options);

  const responseCode = response.getResponseCode();

  const responseText = response.getContentText();

  

  log(logCollector, `Gemini APIレスポンスコード: ${responseCode}`);

  log(logCollector, `Gemini APIレスポンスボディ (先頭500文字): ${responseText.substring(0, 500)}...`);

  

  if (responseCode !== 200) {

      throw new Error(`Gemini APIリクエストに失敗しました。ステータスコード: ${responseCode}, 応答: ${responseText}`);

  }



  const jsonResponse = JSON.parse(responseText);

  

  if (!jsonResponse.candidates || jsonResponse.candidates.length === 0 || !jsonResponse.candidates[0].content || !jsonResponse.candidates[0].content.parts || jsonResponse.candidates[0].content.parts.length === 0) {

    const finishReason = jsonResponse.candidates && jsonResponse.candidates[0] ? jsonResponse.candidates[0].finishReason : 'N/A';

    log(logCollector, `AIからの応答に有効なコンテンツが含まれていませんでした。Finish Reason: ${finishReason}`);

    throw new Error("AIからの応答に有効なコンテンツが含まれていませんでした。APIの応答を確認してください。");

  }

  

  log(logCollector, 'Gemini API 処理正常終了。');

  return jsonResponse.candidates[0].content.parts[0].text.trim();

}



/**

 * AppSheet APIを呼び出して、生成した回答を書き込む

 */

function updateQueryResponse(logCollector, queryId, answerText) {

  log(logCollector, `AppSheetへの回答書き込み処理開始 (Query ID: ${queryId})`);

  const payload = {

    Action: "Edit",

    Properties: { "Locale": "ja-JP", "Timezone": "Asia/Tokyo" },

    Rows: [{

      "query_id": queryId,

      "response_text": answerText,

      "status": "完了"

    }]

  };

  callAppSheetApi(logCollector, payload);

}



/**

 * エラー発生時にAppSheetのステータスを更新する

 */

function updateQueryStatusToError(logCollector, queryId, errorMessage) {

  log(logCollector, `AppSheetへのエラーステータス書き込み処理開始 (Query ID: ${queryId})`);

  const payload = {

    Action: "Edit",

    Properties: { "Locale": "ja-JP", "Timezone": "Asia/Tokyo" },

    Rows: [{

      "query_id": queryId,

      "status": "エラー",

      "error_details": `GAS Script Error: ${errorMessage.substring(0, 255)}`

    }]

  };

  callAppSheetApi(logCollector, payload);

}



/**

 * AppSheet APIを呼び出す共通関数

 */

function callAppSheetApi(logCollector, payload) {

  const apiUrl = `https://api.appsheet.com/api/v2/apps/${SETTINGS.APP_ID}/tables/${SETTINGS.QUERIES_TABLE_NAME}/Action`;

  const options = {

    method: 'post',

    contentType: 'application/json',

    headers: { 'ApplicationAccessKey': SETTINGS.ACCESS_KEY },

    payload: JSON.stringify(payload),

    muteHttpExceptions: true

  };

  

  const payloadForLog = JSON.parse(JSON.stringify(payload));

  if (payloadForLog.Rows && payloadForLog.Rows[0]) {

      const row = payloadForLog.Rows[0];

      if (row.response_text && row.response_text.length > 200) {

          row.response_text = row.response_text.substring(0, 200) + '... (省略)';

      }

      if (row.error_details && row.error_details.length > 200) {

          row.error_details = row.error_details.substring(0, 200) + '... (省略)';

      }

  }



  log(logCollector, `AppSheet APIリクエストURL: ${apiUrl}`);

  log(logCollector, `AppSheet APIリクエストペイロード: ${JSON.stringify(payloadForLog, null, 2)}`);



  const response = UrlFetchApp.fetch(apiUrl, options);

  const responseCode = response.getResponseCode();

  const responseText = response.getContentText();

  

  log(logCollector, `AppSheet APIレスポンスコード: ${responseCode}`);

  log(logCollector, `AppSheet APIレスポンスボディ: ${responseText}`);

  

  if (responseCode >= 300) {

    throw new Error(`AppSheet API Error: ${responseCode} - ${responseText}`);

  }

  log(logCollector, 'AppSheet API 呼び出し成功。');

}