# 実行ログ管理システム

## 概要

全てのGASスクリプトの実行履歴を一元管理するスプレッドシートベースのログシステムです。従来のメール送信方式を廃止し、構造化されたログ管理を実現します。

## システム構成

### 実行ログスプレッドシート

- **スプレッドシート名**: `GAS実行ログ`
- **格納場所**: フォルダーID `16swPUizvdlyPxUjbDpVl9-VBDJZO91kX`
- **シート構成**:
  - メインログシート
  - エラー詳細シート
  - 統計シート

## ログシート構造

### メインログシート

| 列 | 項目名 | 説明 | 例 |
|---|--------|------|-----|
| A | タイムスタンプ | 実行日時 | 2025-01-16 14:30:45 |
| B | スクリプト名 | 実行したGASの名前 | Appsheet_通話_要約生成 |
| C | ステータス | SUCCESS/ERROR/WARNING/INFO | SUCCESS |
| D | 処理概要 | 処理内容の簡潔な説明 | 通話要約を生成しました |
| E | 詳細情報 | エラーメッセージや処理結果 | {"summary": "...", "duration": 2.3} |
| F | リクエストID | 重複チェック用ID | a3f2b9c1... |
| G | 処理時間(秒) | 実行にかかった時間 | 2.34 |
| H | ユーザー | 実行ユーザー | user@example.com |

### エラー詳細シート

エラー発生時の詳細情報を記録：

| 列 | 項目名 | 説明 |
|---|--------|------|
| A | タイムスタンプ | エラー発生日時 |
| B | スクリプト名 | エラーが発生したスクリプト |
| C | エラー種別 | API Error, Parse Error, etc. |
| D | エラーメッセージ | 詳細なエラー内容 |
| E | スタックトレース | エラーの発生箇所 |
| F | リクエストデータ | エラー時の入力データ |
| G | 対応状況 | 未対応/対応中/解決済み |

### 統計シート

実行統計を自動集計：

| 列 | 項目名 | 説明 |
|---|--------|------|
| A | スクリプト名 | - |
| B | 総実行回数 | 当日/週/月 |
| C | 成功回数 | - |
| D | エラー回数 | - |
| E | 成功率(%) | - |
| F | 平均処理時間(秒) | - |
| G | 最終実行日時 | - |

## 実装方法

### 1. ログ記録関数

```javascript
/**
 * 実行ログをスプレッドシートに記録
 * @param {string} status - ログレベル (SUCCESS, ERROR, WARNING, INFO)
 * @param {string} scriptName - スクリプト名
 * @param {string} summary - 処理概要
 * @param {string} details - 詳細情報
 * @param {string} requestId - リクエストID（オプション）
 * @param {number} duration - 処理時間（秒）（オプション）
 */
function logToSheet(status, scriptName, summary, details = '', requestId = '', duration = 0) {
  try {
    // スプレッドシートIDを取得
    const SPREADSHEET_ID = getExecutionLogSpreadsheetId();
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('実行ログ') || ss.getSheets()[0];
    
    // ログデータを作成
    const timestamp = new Date();
    const user = Session.getActiveUser().getEmail();
    
    // 行を追加
    sheet.appendRow([
      timestamp,
      scriptName,
      status,
      summary,
      details,
      requestId,
      duration,
      user
    ]);
    
    // エラーの場合はエラー詳細シートにも記録
    if (status === 'ERROR') {
      logErrorDetails(ss, scriptName, summary, details, timestamp);
    }
    
  } catch (e) {
    // ログ記録自体がエラーになった場合はコンソールに出力
    Logger.log('ログ記録エラー: ' + e.toString());
  }
}
```

### 2. スプレッドシートID管理

```javascript
/**
 * 実行ログスプレッドシートIDを取得
 * ScriptPropertiesに保存されたIDを返す
 */
function getExecutionLogSpreadsheetId() {
  const properties = PropertiesService.getScriptProperties();
  let spreadsheetId = properties.getProperty('EXECUTION_LOG_SPREADSHEET_ID');
  
  // 未設定の場合は作成
  if (!spreadsheetId) {
    spreadsheetId = createExecutionLogSpreadsheet();
    properties.setProperty('EXECUTION_LOG_SPREADSHEET_ID', spreadsheetId);
  }
  
  return spreadsheetId;
}
```

### 3. スプレッドシート作成

```javascript
/**
 * 実行ログスプレッドシートを作成
 */
function createExecutionLogSpreadsheet() {
  const FOLDER_ID = '16swPUizvdlyPxUjbDpVl9-VBDJZO91kX';
  const folder = DriveApp.getFolderById(FOLDER_ID);
  
  // スプレッドシート作成
  const ss = SpreadsheetApp.create('GAS実行ログ');
  const file = DriveApp.getFileById(ss.getId());
  
  // フォルダーに移動
  folder.addFile(file);
  DriveApp.getRootFolder().removeFile(file);
  
  // シート設定
  setupLogSheets(ss);
  
  return ss.getId();
}

/**
 * ログシートの初期設定
 */
function setupLogSheets(ss) {
  // メインログシート
  const mainSheet = ss.getSheets()[0];
  mainSheet.setName('実行ログ');
  mainSheet.appendRow([
    'タイムスタンプ',
    'スクリプト名',
    'ステータス',
    '処理概要',
    '詳細情報',
    'リクエストID',
    '処理時間(秒)',
    'ユーザー'
  ]);
  mainSheet.getRange(1, 1, 1, 8).setFontWeight('bold').setBackground('#4285f4').setFontColor('#ffffff');
  mainSheet.setFrozenRows(1);
  
  // エラー詳細シート
  const errorSheet = ss.insertSheet('エラー詳細');
  errorSheet.appendRow([
    'タイムスタンプ',
    'スクリプト名',
    'エラー種別',
    'エラーメッセージ',
    'スタックトレース',
    'リクエストデータ',
    '対応状況'
  ]);
  errorSheet.getRange(1, 1, 1, 7).setFontWeight('bold').setBackground('#ea4335').setFontColor('#ffffff');
  errorSheet.setFrozenRows(1);
  
  // 統計シート
  const statsSheet = ss.insertSheet('統計');
  setupStatsSheet(statsSheet);
}
```

### 4. エラー詳細記録

```javascript
/**
 * エラー詳細をエラーシートに記録
 */
function logErrorDetails(ss, scriptName, errorType, errorMessage, timestamp) {
  const errorSheet = ss.getSheetByName('エラー詳細');
  if (!errorSheet) return;
  
  // スタックトレースを取得
  const stackTrace = new Error().stack || '';
  
  errorSheet.appendRow([
    timestamp,
    scriptName,
    errorType,
    errorMessage,
    stackTrace,
    '', // リクエストデータ（必要に応じて追加）
    '未対応'
  ]);
}
```

### 5. 統計情報の更新

```javascript
/**
 * 統計シートのセットアップ
 */
function setupStatsSheet(sheet) {
  sheet.appendRow([
    'スクリプト名',
    '総実行回数',
    '成功回数',
    'エラー回数',
    '成功率(%)',
    '平均処理時間(秒)',
    '最終実行日時'
  ]);
  sheet.getRange(1, 1, 1, 7).setFontWeight('bold').setBackground('#34a853').setFontColor('#ffffff');
  sheet.setFrozenRows(1);
}

/**
 * 統計情報を更新（日次バッチで実行）
 */
function updateStatistics() {
  const SPREADSHEET_ID = getExecutionLogSpreadsheetId();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const logSheet = ss.getSheetByName('実行ログ');
  const statsSheet = ss.getSheetByName('統計');
  
  if (!logSheet || !statsSheet) return;
  
  // ログデータを取得
  const logData = logSheet.getDataRange().getValues();
  const headers = logData.shift(); // ヘッダー除去
  
  // スクリプトごとに集計
  const stats = {};
  logData.forEach(row => {
    const scriptName = row[1];
    const status = row[2];
    const duration = row[6] || 0;
    
    if (!stats[scriptName]) {
      stats[scriptName] = {
        total: 0,
        success: 0,
        error: 0,
        totalDuration: 0,
        lastExecution: row[0]
      };
    }
    
    stats[scriptName].total++;
    if (status === 'SUCCESS') stats[scriptName].success++;
    if (status === 'ERROR') stats[scriptName].error++;
    stats[scriptName].totalDuration += parseFloat(duration);
    
    // 最新の実行日時を更新
    if (new Date(row[0]) > new Date(stats[scriptName].lastExecution)) {
      stats[scriptName].lastExecution = row[0];
    }
  });
  
  // 統計シートをクリア
  statsSheet.clear();
  setupStatsSheet(statsSheet);
  
  // 統計データを書き込み
  Object.keys(stats).forEach(scriptName => {
    const s = stats[scriptName];
    const successRate = s.total > 0 ? (s.success / s.total * 100).toFixed(2) : 0;
    const avgDuration = s.total > 0 ? (s.totalDuration / s.total).toFixed(2) : 0;
    
    statsSheet.appendRow([
      scriptName,
      s.total,
      s.success,
      s.error,
      successRate,
      avgDuration,
      s.lastExecution
    ]);
  });
  
  logToSheet('INFO', 'updateStatistics', '統計情報を更新しました');
}
```

## 使用例

### 成功ログ

```javascript
function processData(data) {
  const startTime = new Date().getTime();
  
  try {
    // 処理実行
    const result = doSomething(data);
    
    // 処理時間を計算
    const duration = (new Date().getTime() - startTime) / 1000;
    
    // 成功ログ
    logToSheet(
      'SUCCESS',
      'Appsheet_通話_要約生成',
      '通話要約を生成しました',
      JSON.stringify({ recordId: result.id, summaryLength: result.summary.length }),
      generateRequestId(data),
      duration
    );
    
    return result;
  } catch (error) {
    // エラーログは後述
  }
}
```

### エラーログ

```javascript
function processData(data) {
  try {
    // 処理実行
    // ...
  } catch (error) {
    // エラーログ
    logToSheet(
      'ERROR',
      'Appsheet_通話_要約生成',
      'Gemini API呼び出しエラー',
      error.toString(),
      generateRequestId(data)
    );
    
    throw error; // エラーを再スロー
  }
}
```

### 警告ログ

```javascript
// 重複リクエストをスキップした場合
if (isDuplicateRequest(requestId)) {
  logToSheet(
    'WARNING',
    'Appsheet_通話_要約生成',
    '重複リクエストをスキップしました',
    `RequestID: ${requestId}`
  );
  return;
}
```

### 情報ログ

```javascript
// バッチ処理の開始・終了
logToSheet(
  'INFO',
  'scheduledCleanup',
  'クリーンアップ処理を開始しました'
);

// ... 処理 ...

logToSheet(
  'INFO',
  'scheduledCleanup',
  'クリーンアップ処理を完了しました',
  `削除件数: ${deletedCount}`
);
```

## ログの活用

### 1. エラー監視

```javascript
/**
 * 過去24時間のエラーを取得
 */
function getRecentErrors() {
  const SPREADSHEET_ID = getExecutionLogSpreadsheetId();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const errorSheet = ss.getSheetByName('エラー詳細');
  
  const data = errorSheet.getDataRange().getValues();
  const headers = data.shift();
  
  const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const recentErrors = data.filter(row => {
    return new Date(row[0]) > oneDayAgo;
  });
  
  return recentErrors;
}
```

### 2. パフォーマンス分析

```javascript
/**
 * スクリプトのパフォーマンスを分析
 */
function analyzePerformance(scriptName) {
  const SPREADSHEET_ID = getExecutionLogSpreadsheetId();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const logSheet = ss.getSheetByName('実行ログ');
  
  const data = logSheet.getDataRange().getValues();
  const headers = data.shift();
  
  const scriptLogs = data.filter(row => row[1] === scriptName);
  const durations = scriptLogs.map(row => parseFloat(row[6])).filter(d => d > 0);
  
  if (durations.length === 0) {
    return null;
  }
  
  const avg = durations.reduce((a, b) => a + b, 0) / durations.length;
  const max = Math.max(...durations);
  const min = Math.min(...durations);
  
  return {
    scriptName: scriptName,
    executionCount: durations.length,
    avgDuration: avg.toFixed(2),
    maxDuration: max.toFixed(2),
    minDuration: min.toFixed(2)
  };
}
```

### 3. ダッシュボード作成

Google Data Studioと連携してダッシュボードを作成可能：

- リアルタイムのエラー率
- スクリプト別実行回数
- パフォーマンストレンド
- エラー傾向分析

## メンテナンス

### 古いログの削除

```javascript
/**
 * 90日以上古いログを削除
 */
function cleanupOldLogs() {
  const SPREADSHEET_ID = getExecutionLogSpreadsheetId();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const logSheet = ss.getSheetByName('実行ログ');
  
  const data = logSheet.getDataRange().getValues();
  const cutoffDate = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
  
  // 古い行を特定して削除（下から上へ）
  for (let i = data.length - 1; i > 0; i--) {
    const rowDate = new Date(data[i][0]);
    if (rowDate < cutoffDate) {
      logSheet.deleteRow(i + 1);
    }
  }
  
  logToSheet('INFO', 'cleanupOldLogs', `古いログを削除しました`);
}
```

### ログサイズの監視

```javascript
/**
 * ログシートのサイズを確認
 */
function checkLogSize() {
  const SPREADSHEET_ID = getExecutionLogSpreadsheetId();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const logSheet = ss.getSheetByName('実行ログ');
  
  const rowCount = logSheet.getLastRow();
  const maxRows = 100000; // 10万行を上限とする
  
  if (rowCount > maxRows * 0.9) {
    // 90%を超えたら警告
    logToSheet(
      'WARNING',
      'checkLogSize',
      'ログシートが容量上限に近づいています',
      `現在の行数: ${rowCount} / ${maxRows}`
    );
  }
  
  return rowCount;
}
```

## ベストプラクティス

1. **適切なログレベル使用**
   - ERROR: 処理が失敗した場合のみ
   - WARNING: 異常だが処理は継続
   - SUCCESS: 正常に完了
   - INFO: 参考情報

2. **詳細情報の記録**
   - JSONで構造化されたデータを記録
   - エラー時はスタックトレースも含める
   - リクエストIDで追跡可能に

3. **定期的なメンテナンス**
   - 週次で統計を更新
   - 月次で古いログを削除
   - 四半期でログサイズを確認

4. **セキュリティ**
   - 個人情報は記録しない
   - APIキーなどの機密情報は記録しない
   - アクセス権限を適切に設定

## まとめ

実行ログ管理システムにより、全てのGASスクリプトの動作を一元的に監視・分析できます。メール送信を廃止することで、より構造化された効率的なログ管理を実現しています。

## 参考

- [create_execution_log_spreadsheet.py](../../create_execution_log_spreadsheet.py) - スプレッドシート作成スクリプト
- [check_execution_log_sheet.py](../../check_execution_log_sheet.py) - ログ確認スクリプト
