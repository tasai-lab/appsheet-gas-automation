# 実行ログ管理システム

## 概要

全てのGASスクリプトの実行履歴を一元管理するスプレッドシートベースのログシステムです。従来のメール送信方式を廃止し、構造化されたログ管理を実現します。

## システム構成

### 実行ログスプレッドシート

- **スプレッドシートID**: `16UHnMlSUlnUy-67gbwuvjeeU73AwDomqzJwGi6L4rVA`
- **スプレッドシート名**: `GAS統一実行ログ`
- **格納場所**: フォルダーID `16swPUizvdlyPxUjbDpVl9-VBDJZO91kX`
- **シート名**: `実行履歴`

## ログシート構造

### 実行履歴シート

| 列 | 項目名 | 説明 | 例 |
|---|--------|------|-----|
| A | タイムスタンプ | 実行日時 | 2025/10/16 14:30:45 |
| B | スクリプト名 | 実行したGASの名前 | Appsheet_通話_要約生成 |
| C | ステータス | 成功/失敗/警告/スキップ | 成功 |
| D | リクエストID | 重複チェック用ID | a3f2b9c1... |
| E | 処理概要 | 処理内容の簡潔な説明 | 通話要約を生成しました |
| F | エラーメッセージ | エラー発生時の詳細 | API呼び出しエラー... |
| G | ユーザー | 実行ユーザー | user@example.com |
| H | 処理時間(秒) | 実行にかかった時間 | 2.34 |
| I | API使用 | 使用したAPI | Gemini API |
| J | モデル名 | 使用したモデル | gemini-2.0-flash-exp |
| K | トークン数 | 消費トークン数 | 1500 |
| L | レスポンスサイズ | レスポンスサイズ(KB) | 3.2 |
| M | 入力概要 | 入力データの概要 | 通話ID: 12345 |
| N | 出力概要 | 出力データの概要 | 要約生成完了 |
| O | 備考 | その他メモ | - |

## 実装方法

### 1. ExecutionLoggerモジュール

全スクリプトで共通で使用するExecutionLoggerモジュール：

```javascript
/**
 * 統一実行ログモジュール
 */

// 統一実行ログスプレッドシート
const EXECUTION_LOG_SPREADSHEET_ID = '16UHnMlSUlnUy-67gbwuvjeeU73AwDomqzJwGi6L4rVA';
const EXECUTION_LOG_SHEET_NAME = '実行履歴';

const ExecutionLogger = {
  SPREADSHEET_ID: EXECUTION_LOG_SPREADSHEET_ID,
  SHEET_NAME: EXECUTION_LOG_SHEET_NAME,
  
  /**
   * ログを記録
   */
  log: function(scriptName, status, requestId, details = {}) {
    try {
      const sheet = SpreadsheetApp.openById(this.SPREADSHEET_ID)
        .getSheetByName(this.SHEET_NAME);
      
      if (!sheet) {
        Logger.log(`警告: 実行ログシート "${this.SHEET_NAME}" が見つかりません`);
        return;
      }
      
      const timestamp = new Date();
      const row = [
        Utilities.formatDate(timestamp, Session.getScriptTimeZone(), 'yyyy/MM/dd HH:mm:ss'),
        scriptName,
        status,
        requestId || '',
        details.summary || '',
        details.errorMessage || '',
        details.user || Session.getActiveUser().getEmail(),
        details.processingTime || '',
        details.apiUsed || '',
        details.modelName || '',
        details.tokens || '',
        details.responseSize || '',
        details.inputSummary || '',
        details.outputSummary || '',
        details.notes || ''
      ];
      
      sheet.appendRow(row);
      
    } catch (e) {
      Logger.log(`ログ記録エラー: ${e.message}`);
    }
  },
  
  /**
   * 成功ログ
   */
  success: function(scriptName, requestId, summary, processingTime, details = {}) {
    this.log(scriptName, '成功', requestId, {
      summary: summary,
      processingTime: processingTime,
      ...details
    });
  },
  
  /**
   * エラーログ
   */
  error: function(scriptName, requestId, errorMessage, processingTime, details = {}) {
    this.log(scriptName, '失敗', requestId, {
      errorMessage: errorMessage,
      processingTime: processingTime,
      ...details
    });
  },
  
  /**
   * 警告ログ
   */
  warning: function(scriptName, requestId, summary, processingTime, details = {}) {
    this.log(scriptName, '警告', requestId, {
      summary: summary,
      processingTime: processingTime,
      ...details
    });
  },
  
  /**
   * スキップログ
   */
  skip: function(scriptName, requestId, summary, processingTime, details = {}) {
    this.log(scriptName, 'スキップ', requestId, {
      summary: summary,
      processingTime: processingTime,
      ...details
    });
  }
};

/**
 * 実行時間計測クラス
 */
class ExecutionTimer {
  constructor() {
    this.startTime = new Date();
  }
  
  getElapsedSeconds() {
    const endTime = new Date();
    return ((endTime - this.startTime) / 1000).toFixed(2);
  }
}
```

### 2. 重複防止モジュール

```javascript
/**
 * Webhook重複実行防止モジュール
 */
const DuplicationPrevention = {
  LOCK_TIMEOUT: 300000, // 5分
  CACHE_EXPIRATION: 3600, // 1時間
  
  /**
   * リクエストの重複チェック
   */
  checkDuplicate: function(requestId) {
    const cache = CacheService.getScriptCache();
    const cacheKey = `processed_${requestId}`;
    
    if (cache.get(cacheKey)) {
      Logger.log(`重複リクエストを検出: ${requestId}`);
      return false;
    }
    
    const lock = LockService.getScriptLock();
    try {
      lock.waitLock(this.LOCK_TIMEOUT);
      
      if (cache.get(cacheKey)) {
        Logger.log(`ロック取得後、重複リクエストを検出: ${requestId}`);
        return false;
      }
      
      cache.put(cacheKey, 'processed', this.CACHE_EXPIRATION);
      return true;
    } catch (e) {
      Logger.log(`ロック取得エラー: ${e.message}`);
      return false;
    } finally {
      lock.releaseLock();
    }
  },
  
  /**
   * リクエストIDを生成
   */
  generateRequestId: function(data) {
    const str = JSON.stringify(data);
    return Utilities.computeDigest(
      Utilities.DigestAlgorithm.SHA_256,
      str,
      Utilities.Charset.UTF_8
    ).map(b => (b & 0xFF).toString(16).padStart(2, '0')).join('');
  }
};
```

## 使用例

### 成功ログ

```javascript
function doPostWebhook(e) {
  const timer = new ExecutionTimer();
  const requestId = DuplicationPrevention.generateRequestId(e.postData.contents);
  
  // 重複チェック
  if (!DuplicationPrevention.checkDuplicate(requestId)) {
    ExecutionLogger.skip(
      'Appsheet_通話_要約生成',
      requestId,
      '重複リクエストをスキップ',
      timer.getElapsedSeconds()
    );
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      message: '重複リクエスト'
    }));
  }
  
  try {
    // 処理実行
    const data = JSON.parse(e.postData.contents);
    const result = generateSummary(data);
    
    // 成功ログ
    ExecutionLogger.success(
      'Appsheet_通話_要約生成',
      requestId,
      '通話要約を生成しました',
      timer.getElapsedSeconds(),
      {
        apiUsed: 'Gemini API',
        modelName: 'gemini-2.0-flash-exp',
        inputSummary: `通話ID: ${data.callId}`,
        outputSummary: `要約長: ${result.summary.length}文字`
      }
    );
    
    return ContentService.createTextOutput(JSON.stringify({
      success: true,
      result: result
    }));
    
  } catch (error) {
    // エラーログ
    ExecutionLogger.error(
      'Appsheet_通話_要約生成',
      requestId,
      error.message,
      timer.getElapsedSeconds(),
      {
        inputSummary: e.postData.contents.substring(0, 100)
      }
    );
    
    throw error;
  }
}
```

### エラーログ（Gemini API）

```javascript
function callGeminiAPI(prompt, data) {
  const timer = new ExecutionTimer();
  
  try {
    const response = UrlFetchApp.fetch(GEMINI_API_ENDPOINT, {
      method: 'post',
      contentType: 'application/json',
      payload: JSON.stringify({
        contents: [{
          parts: [{ text: prompt }, { inline_data: data }]
        }]
      })
    });
    
    const result = JSON.parse(response.getContentText());
    
    // API使用ログ
    ExecutionLogger.log('Appsheet_通話_要約生成', '成功', '', {
      summary: 'Gemini API呼び出し成功',
      processingTime: timer.getElapsedSeconds(),
      apiUsed: 'Gemini API',
      modelName: GEMINI_MODEL_PRO,
      tokens: result.usageMetadata?.totalTokenCount || 0,
      responseSize: (response.getContentText().length / 1024).toFixed(2)
    });
    
    return result;
    
  } catch (error) {
    ExecutionLogger.error(
      'Appsheet_通話_要約生成',
      '',
      `Gemini API呼び出しエラー: ${error.message}`,
      timer.getElapsedSeconds(),
      {
        apiUsed: 'Gemini API',
        modelName: GEMINI_MODEL_PRO,
        notes: error.stack
      }
    );
    throw error;
  }
}
```

### トリガー実行（Automation）

```javascript
function mainProcessPersonalReceipts() {
  const timer = new ExecutionTimer();
  const requestId = Utilities.getUuid();
  
  // 重複実行チェック
  const lockKey = 'personal_receipt_processing';
  const scriptProperties = PropertiesService.getScriptProperties();
  const existingLock = scriptProperties.getProperty(lockKey);
  
  if (existingLock) {
    const lockTime = new Date(existingLock);
    const now = new Date();
    if ((now - lockTime) < 300000) { // 5分以内
      ExecutionLogger.skip(
        'Automation_レシート(個人)',
        requestId,
        '他の処理が実行中のためスキップ',
        timer.getElapsedSeconds()
      );
      return;
    }
  }
  
  scriptProperties.setProperty(lockKey, new Date().toISOString());
  
  try {
    // 処理実行
    const result = processReceipts();
    
    ExecutionLogger.success(
      'Automation_レシート(個人)',
      requestId,
      `処理完了: ${result.processedCount}件`,
      timer.getElapsedSeconds(),
      {
        outputSummary: `成功: ${result.successCount}件, エラー: ${result.errorCount}件`
      }
    );
    
  } catch (error) {
    ExecutionLogger.error(
      'Automation_レシート(個人)',
      requestId,
      error.message,
      timer.getElapsedSeconds()
    );
  } finally {
    scriptProperties.deleteProperty(lockKey);
  }
}
```

## ログの活用

### ログの確認

スプレッドシート（ID: `16UHnMlSUlnUy-67gbwuvjeeU73AwDomqzJwGi6L4rVA`）を開いて、以下の情報を確認できます：

- 各スクリプトの実行状況
- エラー発生状況
- API使用状況（モデル、トークン数）
- 処理時間のトレンド

### フィルタ活用

スプレッドシートのフィルタ機能を使用して：

- 特定のスクリプトのログのみ表示
- エラーのみ表示（ステータス = "失敗"）
- 特定期間のログを抽出
- 処理時間が長いログを抽出

### データポータルとの連携

Google Data Studio（Looker Studio）と連携してダッシュボードを作成可能：

- リアルタイムのエラー率グラフ
- スクリプト別実行回数の推移
- API使用量の可視化
- パフォーマンストレンド分析

## ベストプラクティス

1. **適切なステータス使用**
   - 成功: 処理が正常に完了
   - 失敗: エラーが発生して処理が中断
   - 警告: 異常だが処理は継続
   - スキップ: 重複などで処理をスキップ

2. **詳細情報の記録**
   - API使用時は必ずモデル名とトークン数を記録
   - エラー時はスタックトレースも含める
   - リクエストIDで処理を追跡可能に

3. **パフォーマンス監視**
   - 処理時間を必ず記録
   - 異常に遅い処理を定期的にチェック

4. **セキュリティ**
   - 個人情報は記録しない
   - APIキーなどの機密情報は記録しない
   - 入力/出力データは概要のみ記録

## まとめ

統一実行ログシステムにより、全32個のGASスクリプトの動作を一元的に監視・分析できます。メール送信を廃止し、構造化された効率的なログ管理を実現しています。

## 関連ドキュメント

- [重複防止機能](重複防止機能.md) - Webhook重複実行の防止
- [Geminiモデル仕様](Geminiモデル仕様.md) - API使用ガイド
- [デプロイガイド](デプロイガイド.md) - デプロイ手順
