# 重複実行防止機能

## 概要

Webhook経由でGASが複数回呼び出される問題を解決するため、リクエストIDベースの重複チェック機能を実装しています。

## 問題の背景

### 発生する問題
- 同一のWebhookイベントが複数回送信される
- GASが重複して実行される
- データの二重登録や誤った処理が発生

### 原因
- Webhookプロバイダーのリトライ処理
- ネットワークの不安定性
- タイムアウト後の再送信

## 実装方式

### 1. リクエストIDの生成

各リクエストに対して一意のIDを生成：

```javascript
/**
 * リクエストIDを生成
 * データの内容からハッシュ値を生成して重複チェックに使用
 */
function generateRequestId(data) {
  const content = JSON.stringify(data);
  const hash = Utilities.computeDigest(
    Utilities.DigestAlgorithm.SHA_256,
    content,
    Utilities.Charset.UTF_8
  );
  return Utilities.base64Encode(hash);
}
```

### 2. 重複チェック

ScriptPropertiesを使用した軽量な実装：

```javascript
/**
 * リクエストが既に処理済みかチェック
 * @param {string} requestId リクエストID
 * @return {boolean} true: 処理済み（重複）, false: 未処理
 */
function isDuplicateRequest(requestId) {
  const properties = PropertiesService.getScriptProperties();
  const key = `processed_${requestId}`;
  
  // 既に処理済みかチェック
  if (properties.getProperty(key)) {
    Logger.log(`重複リクエストを検出: ${requestId}`);
    return true;
  }
  
  // 処理済みとしてマーク（24時間保持）
  const expiryTime = new Date().getTime() + (24 * 60 * 60 * 1000);
  properties.setProperty(key, expiryTime.toString());
  
  return false;
}
```

### 3. 期限切れデータの削除

古いデータを自動的に削除：

```javascript
/**
 * 期限切れの処理済みリクエストを削除
 */
function cleanupExpiredRequests() {
  const properties = PropertiesService.getScriptProperties();
  const allProperties = properties.getProperties();
  const currentTime = new Date().getTime();
  
  Object.keys(allProperties).forEach(key => {
    if (key.startsWith('processed_')) {
      const expiryTime = parseInt(allProperties[key]);
      if (currentTime > expiryTime) {
        properties.deleteProperty(key);
        Logger.log(`期限切れリクエストを削除: ${key}`);
      }
    }
  });
}
```

## 使用方法

### doPost関数での実装例

```javascript
function doPost(e) {
  try {
    // リクエストデータの取得
    const data = JSON.parse(e.postData.contents);
    
    // リクエストIDの生成
    const requestId = generateRequestId(data);
    
    // 重複チェック
    if (isDuplicateRequest(requestId)) {
      logToSheet('WARNING', 'スクリプト名', '重複リクエストをスキップ', requestId);
      return ContentService.createTextOutput(JSON.stringify({
        status: 'skipped',
        message: '重複リクエストのため処理をスキップしました'
      })).setMimeType(ContentService.MimeType.JSON);
    }
    
    // 実際の処理
    const result = processRequest(data);
    
    // 成功ログ
    logToSheet('SUCCESS', 'スクリプト名', '処理完了', JSON.stringify(result));
    
    return ContentService.createTextOutput(JSON.stringify({
      status: 'success',
      result: result
    })).setMimeType(ContentService.MimeType.JSON);
    
  } catch (error) {
    // エラーログ
    logToSheet('ERROR', 'スクリプト名', error.toString(), e.postData.contents);
    
    return ContentService.createTextOutput(JSON.stringify({
      status: 'error',
      message: error.toString()
    })).setMimeType(ContentService.MimeType.JSON);
  }
}
```

### 定期的なクリーンアップ

トリガーを設定して定期実行：

```javascript
/**
 * 時間駆動トリガーで1日1回実行
 */
function scheduledCleanup() {
  cleanupExpiredRequests();
  logToSheet('INFO', 'クリーンアップ', '期限切れリクエストを削除しました');
}
```

## 設定方法

### 1. スクリプトへの組み込み

重複防止コードを各スクリプトに追加：

```javascript
// DuplicationPrevention.gs の内容をコピー
```

### 2. トリガーの設定

GASエディタで以下を設定：

1. トリガーメニューを開く
2. 「トリガーを追加」をクリック
3. 設定:
   - 実行する関数: `scheduledCleanup`
   - イベントのソース: `時間主導型`
   - 時間ベースのトリガー: `日付ベースのタイマー`
   - 時刻: `午前3時～午前4時`

### 3. スクリプトプロパティの確認

必要に応じてScriptPropertiesの容量を確認：

```javascript
function checkPropertiesSize() {
  const properties = PropertiesService.getScriptProperties();
  const allProperties = properties.getProperties();
  
  const size = JSON.stringify(allProperties).length;
  const maxSize = 9 * 1024; // 9KB (制限は約9KB)
  
  Logger.log(`現在のサイズ: ${size} bytes / ${maxSize} bytes`);
  Logger.log(`使用率: ${(size / maxSize * 100).toFixed(2)}%`);
}
```

## パフォーマンス考慮事項

### ScriptPropertiesの制限

- **最大容量**: 約9KB
- **推奨**: 常に50%以下に保つ
- **対策**: 定期的なクリーンアップ

### 保持期間の調整

必要に応じて保持期間を調整：

```javascript
// 24時間 → 12時間に短縮
const expiryTime = new Date().getTime() + (12 * 60 * 60 * 1000);

// 24時間 → 48時間に延長
const expiryTime = new Date().getTime() + (48 * 60 * 60 * 1000);
```

### 代替実装（大量リクエストの場合）

ScriptPropertiesが不足する場合は、Spreadsheetを使用：

```javascript
/**
 * Spreadsheetベースの重複チェック（大量リクエスト向け）
 */
function isDuplicateRequestSheet(requestId) {
  const ss = SpreadsheetApp.openById('SPREADSHEET_ID');
  const sheet = ss.getSheetByName('ProcessedRequests') || 
                ss.insertSheet('ProcessedRequests');
  
  // ヘッダーが無い場合は追加
  if (sheet.getLastRow() === 0) {
    sheet.appendRow(['RequestID', 'Timestamp', 'ExpiryTime']);
  }
  
  // 既存のリクエストIDを検索
  const data = sheet.getDataRange().getValues();
  const found = data.some(row => row[0] === requestId);
  
  if (found) {
    Logger.log(`重複リクエストを検出: ${requestId}`);
    return true;
  }
  
  // 新規リクエストとして記録
  const now = new Date();
  const expiry = new Date(now.getTime() + (24 * 60 * 60 * 1000));
  sheet.appendRow([requestId, now, expiry]);
  
  return false;
}
```

## テスト方法

### 1. 単体テスト

```javascript
function testDuplicationPrevention() {
  const testData = { test: 'data', timestamp: new Date().getTime() };
  const requestId = generateRequestId(testData);
  
  Logger.log(`RequestID: ${requestId}`);
  
  // 初回は重複なし
  const isDup1 = isDuplicateRequest(requestId);
  Logger.log(`1回目: ${isDup1}`); // false
  
  // 2回目は重複検出
  const isDup2 = isDuplicateRequest(requestId);
  Logger.log(`2回目: ${isDup2}`); // true
  
  // 異なるデータは重複なし
  const testData2 = { test: 'different', timestamp: new Date().getTime() };
  const requestId2 = generateRequestId(testData2);
  const isDup3 = isDuplicateRequest(requestId2);
  Logger.log(`異なるデータ: ${isDup3}`); // false
}
```

### 2. 統合テスト

実際のWebhookをシミュレート：

```javascript
function testWebhookDuplication() {
  const testPayload = {
    event: 'test',
    data: { id: 123, name: 'テスト' }
  };
  
  // 1回目の送信
  const e1 = {
    postData: {
      contents: JSON.stringify(testPayload)
    }
  };
  const result1 = doPost(e1);
  Logger.log('1回目の結果:', result1.getContent());
  
  // 2回目の送信（重複）
  const result2 = doPost(e1);
  Logger.log('2回目の結果（重複）:', result2.getContent());
}
```

## トラブルシューティング

### 重複が検出されない

**原因**: リクエストIDの生成ロジックの問題

**対策**:
```javascript
// タイムスタンプを除外してハッシュ生成
function generateRequestId(data) {
  // タイムスタンプなどの可変値を除外
  const { timestamp, ...staticData } = data;
  const content = JSON.stringify(staticData);
  // ...
}
```

### ScriptPropertiesが満杯

**原因**: クリーンアップが実行されていない

**対策**:
1. 手動でクリーンアップ実行
2. トリガーの設定確認
3. 保持期間を短縮

### パフォーマンス低下

**原因**: ScriptPropertiesの読み書きが遅い

**対策**:
1. Spreadsheetベースの実装に変更
2. キャッシュの活用
3. バッチ処理の導入

## ベストプラクティス

1. **適切な保持期間**: 24時間が推奨
2. **定期的なクリーンアップ**: 1日1回実行
3. **ログの記録**: 重複検出時もログに記録
4. **モニタリング**: ScriptPropertiesの使用量を監視
5. **テスト**: デプロイ前に必ずテスト実行

## まとめ

重複実行防止機能により、Webhook経由の重複リクエストを効果的に防ぐことができます。シンプルで軽量な実装のため、全てのスクリプトに容易に適用可能です。

## 参考

- [DuplicationPrevention.gs](../../DuplicationPrevention.gs) - 実装コード
- [DUPLICATION_PREVENTION_GUIDE.md](../../DUPLICATION_PREVENTION_GUIDE.md) - 英語版ガイド
